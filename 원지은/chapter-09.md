# 유연한 설계

## 유연성

- 유연하고 재사용 가능한 설계란 런타임 의존성과 컴파일타임 의존성의 차이를 인식하고 동일한 컴파일타임 의존성으로부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미한다.
- 설계의 미덕은 단순함과 명확함으로부터 나온다.
  - 단순하고 명확한 설계를 가진 코드는 읽기 쉽고 이해하기도 편하다.
- 유연성은 항상 복잡성을 수반하고 불필요한 유연성은 불필요한 복잡성을 낳는다.
  - 설계가 복잡한 이유는 무엇인가?
  - 어떤 변경에 대비하기 위해 설계를 복잡하게 만들었는가?
  - 아직 일어나지 않은 변경은 변경이 아니다.
  - 유연성은 코드를 읽는 사람들이 복잡함을 수용할 수 있을 때만 가치가 있다.
- 유연한 설계를 단순하고 명확하게 만드는 유일한 방법은 사람들 간의 긴밀한 커뮤니케이션뿐이다.

## 개방-폐쇄 원칙 (Open-Closed Principle, OCP)

- 소프트웨어 요소는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다.
- 유연한 설계란 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 확장할 수 있는 설계를 말한다.

### 컴파일타임 의존성과 런타임 의존성

- 컴파일타임 의존성은 코드에서 드러나는 클래스들 사이의 관계
- 런타임 의존성은 실행 시에 협력에 참여하는 객체들 사이의 관계

#### 컴파일타임 의존성

- 새로운 클래스 추가해서 기능을 확장할 수 있도록 허용한다.
  - 확장에 대해서 열려 있다.
- 기존 코드를 수정할 필요 없이 새로운 클래스를 추가하는 것만으로 새로운 기능을 확장할 수 있다.
  - 수정에 대해서는 닫혀 있다.

#### 추상화

- 추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.
  - 개방-폐쇄 원칙의 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 추상화의 결과물이다.
  - 공통적인 부분은 문맥이 바뀌더라도 수정할 필요가 없어야 한다.
    - 따라서, 추상화 부분은 수정에 대해 닫혀 있다.
  - 변경에 의한 파급 효과를 최소화하기 위해서는 변화하는 부분과 변하지 않는 부분이 무엇인지를 이해하고 이를 기반으로 추상화를 설계해야 한다.

### 생성과 사용 분리

- 유연하고 재사용 가능한 설계를 원한다면 객체에 대한 생성과 사용을 분리해야 한다.
  - 객체를 생성할 책임을 클라이언트로 옮긴다.
  - 클라이언트가 특정한 컨텍스트에서 어떤 객체를 생성할지 결정하도록 하는 것이다.
    - 클라이언트가 객체의 생성과 사용의 책임을 함께 가지고 있다.
    - 객체의 생성과 사용을 분리하면 객체의 생성 방식을 변경하더라도 클라이언트 코드를 수정할 필요가 없다. -> FACTORY 패턴

### FACTORY

- 객체의 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체. 순수한 가공물.
  - 클라이언트는 객체 사용과 관련된 책임만 지고 생성과 관련된 책임은 FACTORY에게 위임한다.
- FACTORY는 객체 생성에 특화된 객체이므로 도메인 모델에 속하지 않는다.
- FACTORY는 객체 생성에 대한 책임을 클라이언트로부터 분리하기 위한 객체이다.
  - 결함도를 낮추고 재사용성을 높이기 위해 도메인 개념에게 할당돼 있던 객체 생성 책임을 FACTORY로 옮긴다.

## 의존성 주입 (Dependency Injection, DI)

- 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
- 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필용한 런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭

1. 생성자 주입(Constructor Injection)
2. setter 주입(Setter Injection)
3. 메서드 주입(Method Injection)

### SERVICE LOCATOR 패턴

- 의존성을 해결할 객체들을 보관하는 일종의 저장소
- 가장 큰 단점은 의존성을 감춘다는 것이다.
  - 코드 내부에 명시적으로 드러나지 않는 의존성은 코드를 이해하기 어렵게 만들고 테스트하기 어렵게 만든다.

### 캡슐화

- 캡슐화는 코드를 읽고 이해하는 행위와 관련이 있다.
  - 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 좋은 코드이다.
  - 클래스의 사용법을 익히기 위해 구현 내부를 샅샅이 뒤져야 한다면 캡슐화가 잘 되어 있지 않은 것이다.
- 숨겨진 의존성은 의존성을 이해하기 위해 코드의 내부 구현을 이해할 것을 강요한다.

## 의존성 역전 원칙 (Dependency Inversion Principle, DIP)

- 용어를 최초로 착안한 로버트 마틴은 '역전'이라는 단어를 사용한 이유에 대해 "설계는 의존성의 방향이 전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 때문"이라고 설명한다.
- 상위 수준 모듈과 하위 수준 모듈이 모두 추상화에 의존한다.
  - 상위 수준의 변경에 의해 하위 수준이 변경되는 것은 납득할 수 있지만 하위 수준의 변경으로 인해 상위 수준이 변경돼서는 곤란하다.
