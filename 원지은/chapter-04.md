# 설계 품질과 트레이드오프

객체지향 설계란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동이다. 이러한 설계는 변경에 유연하고 확장 가능한 코드를 만드는 것을 목표로 한다. 훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다. 객체의 상태가 아니라 객체의 행동에 초점을 맞추는 것이다. 객체의 책임에 초점을 맞추는 것이다.

## 설계 트레이드오프

설계가 필요한 이유는 요구사항이 변경되기 때문이고, 캡슐화가 중요한 이유는 불안정한 부분과 안정적인 부분을 분리해서 변경의 영향을 통제할 수 있기 때문이다.

    - 구현이 아닌 인터페이스에 의존하도록 코드를 작성해야 낮은 결합도를 가진다.

## 캡슐화

캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다. 변경될 수 있는 어떤 것이라도 감추는 것이다. 즉, 객체 내부의 상태를 외부로부터 감추는 것 뿐만 아니라 객체가 어떻게 구현되었는지에 대한 세부사항도 감추는 것이다. 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법으로, 내부 구현의 변경으로 인해 외부의 객체가 영향을 받지 않도록 하는 것이다.

    - 변경될 가능성이 높은 부분: 구현
    - 변경될 가능성이 낮은 부분: 인터페이스

### 접근자(accessor)와 변경자(mutator)

- private 변수를 public으로 노출시키는 것은 캡슐화를 위반하는 것이다. 즉, 속성을 private으로 선언했다고 해도 accessor/mutator 메서드를 통해 속성에 접근할 수 있다면 캡슐화를 위반한 것이다. 그러나 이것이 반드시 모든 내부 상태를 외부에 노출하지 않아야 한다는 것을 의미하지 않는다.
- accessor 메서드는 객체의 내부 상태에 대한 읽기 전용 접근을 제공한다. 이는 객체의 상태를 외부에서 직접 변경할 수 없도록 하여 객체의 무결성을 보호하는 방법이다.
- accessor 메서드를 제공함으로써 객체의 내부 구현에 대한 의존성이 생기지 않도록 주의해야 한다.
  - 객체의 특정 상태를 직접적으로 노출하지 않고 그 상태를 기반으로 계산된 결과나 결정을 반환하는 메서드를 제공하는 것이 좋다.

### 데이터를 책임지는 객체

- 객체는 단순한 데이터 제공자가 아니다.
- 따라서, 객체를 생성할 때 두 가지 질문을 통해 바람직한 객체를 설계할 수 있다.
    1. 객체가 어떤 데이터를 포함, 관리해야 하는가?
    2. 객체가 데이터를 어떻게 사용해야 하는가?
        - 데이터에 대해 수행할 수 있는 작업은 무엇인가?
        - 데이터를 처리하기 위해 어떤 오퍼레이션이 필요한가?

### 캡슐화 위반 사례

- 메서드가 객체 내부에 있는 데이터를 인터페이스를 통해 외부에 노출하는 경우
  - 메서드 이름
  - 메서드 시그니처
  - 메서드의 반환값

### 캡슐화 검토

1. 객체 내부의 데이터를 외부에서 직접 수정할 수 있는지 확인
    - ex. 객체 내부의 데이터를 외부에서 직접 수정할 수 있다면 캡슐화가 깨진 것이다.
2. 요구사항 변경으로 인해 객체 내부의 데이터가 추가, 수정, 삭제가 될 가능성이 있는지 확인
    - ex. 객체 A의 데이터가 추가, 수정, 삭제 되었을 때 의존하는 객체 B를 수정해야 한다면 캡슐화가 깨진 것이다. (높은 결합도)
3. 객체 내부의 데이터가 추가, 수정, 삭제 되었을 때 외부 객체에 영향을 미치는지 확인
    - ex. 추가, 수정, 삭제 되었을 때 코드의 여러 곳을 동시에 수정해야 한다면 캡슐화가 깨진 것이다. (낮은 응집도)
4. 변경의 이유가 다른 코드들을 하나의 모듈 안에 뭉쳐놓은 것은 아닌지 확인
    - ex. 변경의 이유가 서로 다른 코드들을 하나의 모듈에서 수정해야 하는 경우 캡슐화가 깨진 것이다. (낮은 응집도)

## 토론 주제

### 높은 응집도, 낮은 결합도를 위한 FE 설계 원칙

    - SOLID 원칙 중 SRP (Single Responsibility Principle)의 적용 사례와 한계
    - SRP를 적용할 때 발생할 수 있는 과도한 분리와 그로 인한 관리 복잡성

### State Management에서의 캡슐화 위반 여부

    - 상태 관리 시스템에서 get/set 메서드 사용이 캡슐화 원칙을 위반하는지, 그리고 이를 어떻게 개선할 수 있는지

### 객체의 상태와 행동의 적절한 분리 방법

    - 객체의 상태(속성)와 행동(메서드)을 어떻게 구분하고 설계해야 하는지

### 객체지향 설계 원칙을 적용한 리팩터링과 코드 리뷰

### 객체지향 설계 원칙 위반 사례와 해결책
