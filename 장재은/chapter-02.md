# 01. 영화 예매 시스템

- 규칙
    - 영화 1개 - 0 또는 1개의 할인 정책
    - 할인 조건은 다수 가능
    - 순서 조건, 기간 조건 섞는 것도 가능

# 02. 객체지향 프로그래밍을 향해

## 협력, 객체, 클래스

- 객체지향 : 객체를 지향하는 것
- 보통이라면 어떤 클래스가 필요한지 고민 → 클래스 결정 후 클래스에 어떤 속성, 메서드가 필요한지 고민
- 진정한 객체지향 패러다임으로의 전환: 클래스가 아닌 객체에 초점을 맞춰야 함
- 집중할 두 가지
    1. 어떤 `클래스`가 필요한지 전에 어떤 `객체` 가 필요한지 고민
        - `클래스` : 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것
        - 어떤 객체들이 어떤 상태와 행동을 가지는지 먼저 결정
        - 객체를 중심에 둬야 함
    2. 객체를 독립적인 존재가 아닌 기능 구현을 위해 협력하는 공동체의 일원으로 봐야 함
        - 객체는 홀로 존재하는 것이 아님
        - 다른 객체에 도움을 주거나 의존하며 살아가는 협력적인 존재
- 객체 윤곽이 잡히면 → 객체 분류 → 이 타입 기반으로 클래스 구현

## 도메인의 구조를 따르는 프로그램 구조

- `도메인`: 문제 해결 위해 사용자가 프로그램을 사용하는 분야
- 객체지향의 강력함 : 요구사항 분석 초기 단계부터 구현 마지막 단계까지 객체라는 동일한 추상화 기법 사용 가능
- 요구사항과 프로그램을 객체라는 동일한 관점에서 바라볼 수 있음
- 클래스의 이름 : 대응되는 도메인 개념의 이름과 동일하거나 유사하게 지어야 함
- 클래스 사이의 관계: 도메인 개념 사이의 관계와 유사하게 만들어 프로그램의 구조를 이해, 예상하기 쉽게 만들어야 함

## 클래스 구현하기

- 인스턴스 변수의 가시성은 private, 메서드의 가시성은 public
- 클래스의 경계를 구분 짓는 것이 중요
- 클래스
    - 내부와 외부로 구분됨
    - 외부에 공개할 부분, 감출 부분을 결정하는 것이 핵심
    - 외부에서는 객체 속성에 직접 접근할 수 없게 하고, public 메서드 통해서만 내부 상태 변경하도록 해야 함
- 경계의 명확성이 객체의 자율성의 보장 → 프로그래머에게 구현의 자유 제공

### 자율적인 객체

1. 객체: 상태와 행동을 함께 가지는 복합적 존재
2. 객체: 스스로 판단하고 행동하는 자율적 존재
- 캡슐화 : 데이터와 기능을 객체 내부로 함께 묶는 것
- 접근 제어 메커니즘 : 외부에서의 접근을 통제
- 접근 수정자: 접근 제어 위해 제공하는 public, protected, private
- 객체지향의 핵심 : 스스로 상태 관리, 판단, 행동하는 자율적 객체들의 공동체를 구성하는 것
    - 외부에서는 객체의 내부 상태를 알 수 없어야 함
- 캡슐화와 접근 제어는 객체를 두 부분으로 나눔
    - 퍼블릭 인터페이스 : 외부에서 접근 가능한 부분
    - 구현 : 외부에서 접근 불가, 오직 내부에서만 접근 가능
        
        ⇒ `인터페이스와 구현의 분리` : 핵심 원칙
        
- private : 클래스의 속성
- public : 외부 제공 일부 메서드
- protected나 private : 어떤 메서드들이 서브클래스나 내부에서만 접근 가능해야 할 때

### 프로그래머의 자유

- 역할을 클래스 작성자, 클라이언트 프로그래머로 구분하는 게 유용
- 클라이언트 프로그래머 : 필요한 클래스를 엮어 앱 구축
- 클래스 작성자 : 필요 부분만 공개, 나머지는 숨김
    
    ⇒ `구현 은닉`
    
- 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 함
- 설계가 필요한 이유 : 변경을 관리하기 위해서
- 변경 가능 구현 내용은 숨겨서 변경으로 인한 혼란 최소화

## 협력하는 객체들의 공동체

- 하나의 인스턴스 변수만 포함해도 개념을 명시적으로 표현하는 것이 명확성과 유연성을 높임
- `협력` : 시스템의 기능 구현을 위해 객체 사이에 이뤄지는 상호작용
- 객체 지향 프로그램 작성 : 협력 관점에서 필요한 객체 결정 → 객체들의 공통 상태와 행위 구현 위해 클래스 작성

## 협력에 관한 짧은 이야기

- 메시지 전송 : 객체 간 상호작용할 수 있는 유일한 방법
- 메시지 수신한 객체 : 메서드를 통해 수신 메시지 처리
- 메시지를 처리하는 방법을 결정 : Movie 스스로의 문제

# 03. 할인 요금 구하기

- calculateMovieFee 메서드 : discountPolicy에 calculateDiscountAmount 메시지를 전송해 할인 요금을 반환받음
- Movie는 기본요금인 fee에서 반환된 할인 요금을 차감
- 숨겨진 두 가지 개념 : 상속, 다형성
    
    ⇒ 기반에는 추상화 원리가 숨겨져 있음
    

## 할인 정책과 할인 조건

- 두 클래스의 중복 코드 제거 위해 공통 코드 보관
    
    ⇒ 부모 클래스 생성
    
- DiscountPolicy의 인스턴스를 생성 할 필요가 없기 때문에 추상 클래스로 구현
- 할인 조건 만족하는 DiscountCondition이 하나라도 존재하는 경우에는 추상 메서드(abstract method)인 getDiscountAmourvt 메서드를 호출해 할인 요금을 계산
- 만족하는 할인 조건이 하나도 존재하지 않는다면 할인 요금으로 0원을 반환
- `TEMPLATE METHOD 패턴` : 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴

## 할인 정책 구성하기

- 생성자 파라미터 목록 이용해 초기화에 필요한 정보 전달 강제하면 올바를 상태를 가진 객체 생성 보장 가능

# 04. 상속과 다형성

## 컴파일 시간 의존성과 실행 시간 의존성

- 클래스 간 의존성 존재 : 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우
- 코드 수준에서 Movie 클래스는 이 두 클래스 중 어떤 것에도 의존하지 않고 오직 추상 클래스인 DiscountPolicy에만 의존하고 있음
- 실행 시점에는 Movie의 인스턴스 는 AmountDiscountPolicy나 PercentDiscountPolicy의 인스턴스에 의존하게 됨
- 코드의 의존성, 실행 시점의 의존성이 다를 수 있음
- 클래스 사이 의존성, 객체 사이의 의존성은 다를 수 있음
- 의존성이 다르면 이해하기 어려워지지만 유연성 있고 확장 가능해짐 → 트레이드오프의 산물
- 유연성과 가독성 사이에 고민 필요

## 차이에 의한 프로그래밍

- 상속 : 클래스의 코드를 수정하지 않고 재사용하는 것
- 상속 이용 → 클래스 사이 관계 설정만으로도 기존 클래스가 가지는 모든 속성, 행동을 새로운 클래스에 포함시킬 수 있음
- 차이에 의한 프로그래밍 : 부모 클래스와 다른 부분만을 추가해 새로운 클래스를 쉽고 빠르게 만드는 방법

## 상속과 인터페이스

- 상속의 가치 : 부모 클래스 제공 인터페이스를 자식 클래스가 물려받을 수 있음
- 인터페이스 : 객체가 이해할 수 있는 메시지의 목록을 정의
- 자식 클래스는 부모 클래스가 수신 가능한 모든 메시지를 수신 가능 → 외부 객체는 자식 클래스를 부모 클래스와 동일한 타입으로 간주할 수 있음
- Movie는 협력 객체가 calculateDiscountAmount라는 메시지를 이해할 수만 있다면 그 객체가 어떤 클래스의 인스턴스인지는 상관하지 않음
- 컴파일러는 코드 상에서 부모 클래스가 나오는 모든 장소에서 자식 클래스 사용하는 것을 허용
- `업캐스팅` : 자식 클래스가 부모 클래스를 대신하는 것

### 다형성

- 메시지, 메서드는 다른 개념
- 다형성
    - 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지 수신 객체의 클래스에 따라 달라짐
    - 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 함
    - 동일한 메시지 수신 시 객체 타입에 따라 다르게 응답할 수 있는 능력
- 지연 바인딩, 동적 바인딩
    - 메시지와 메서드를 실행 시점에 바인딩하는 것
- 초기 바인딩, 정적 바인딩
    - 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것
- 클래스 상속이 다형성 구현의 유일한 방법은 아님
- 구현 상속과 인터페이스 상속
    - 구현 상속 : 코드 재사용 목적으로 상속 사용
    - 인터페이스 상속 : 다형적 협력을 위해 부모와 자식 클래스가 인터페이스를 공유하도록 상속하는 것

# 05. 추상화와 유연성

## 추상화의 힘

- 추상화 두 가지 장점
    1. 요구사항의 정책을 높은 수준에서 서술 가능
    2. 설계가 유연해짐
- 재사용 가능한 설계의 기본을 이루는 디자인 패턴, 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용함
- 추상화를 이용해 상위 정책 표현 시 구조 수정 없이도 새 기능 추가, 확장이 쉬워짐

## 유연한 설계

- 책임의 위치 결정을 위해 조건문 사용하는 것은 협력의 설계 측면에서 좋지 않은 선택
- 항상 예외 케이스 최소화하고 일관성 유지 가능한 방법을 선택하라
- 추상화 중심으로 코드 구조 설계 시 유연하고 확장 가능한 설계를 만들 수 있음
- 추상화는 설계가 구체적인 상황에 결합되는 것을 방지함
- Movie는 특정한 할인 정책에 묶이지 않고 할인 정책을 구현한 클래스가 DiscountPolicy를 상속 받고 있다면 어떤 클래스와도 협력이 가능

## 추상 클래스와 인터페이스 트레이드오프

- 부모 클래스인 DiscountPolicy에서 할인 조건이 없을 때 getDiscountAmountO 메서드를 호출하지 않아 부모 클래스인 DiscountPolicy와 NoneDiscountPolicy를 개념적으로 결합시킴
    
    ⇒ 해결책 : DiscountPolicy를 인터페이스로 바꾸고 NoneDiscountPolicy가 DiscountPolicy 의 getDiscountAmount() 메서드가 아닌 calculateDiscountAmount() 오퍼레이션을 오버라이딩하도록 변경
    
- 이상적으로는 인터페이스를 사용하도록 변경한 설계가 더 좋지만 현실적으로는 NoneDiscountPolicy만을 위해 인터페이스를 추가하는 것이 과함
- 트레이드오프 시에 합당한 이유가 있어야 함

## 코드 재사용

- 상속이 널리 사용되지만 합성이 더 좋은 방법
- 합성 : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해 재사용하는 방법

## 상속

- 두 가지 단점
    1. 캡슐화를 위반함
        1. 부모 클래스 내부 구조를 잘 알하야 하지만 부모 클래스 구현이 노출돼 결합되도록 만듦
    2. 설계를 유연하지 못하게 만듦
- 상속보다 인스턴스 변수로 관계 연결한 설계가 더 유연함

## 합성

- 상속과 다른 점 : 상속이 부모, 자식 클래스를 컴파일 시점에 결합하는데 비해 합성은 Movie가 DiscountPolicy의 인터페이스를 통해 약하게 결합됨
- 인터페이스에 정의된 메시지만으로 코드를 재사용하는 법
- 합성은 상속의 두 가지 문제점을 해결함
    - 인터페이스에 정의된 메시지 통해서만 재사용 가능해 구현을 효과적으로 캡슐화할 수 있음
    - 의존하는 인스턴스 교체가 비교적 쉬워 설계를 유연하게 만듦
    
    ⇒ 코드 재사용 위해서는 상속보다 합성을 선호하는 것이 더 좋음
    
- 코드 재사용하는 경우 상속보다 합성 선호하는 것이 옳지만 다형성을 위해 인터페이스 재사용하는 경우 상속/합성을 조합해 사용할 수 밖에 없음
- 객체지향 설계의 핵심 : 적절한 협력 식별, 필요한 역할 정의 후에 역할 수행 가능한 적절한 객체에게 적절한 책임을 할당하는 것
