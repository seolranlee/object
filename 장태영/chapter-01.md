## Chapter 01 객체, 설계

[학습 코드](https://github.com/taeyoungs/study-object/tree/main/src/_01_ticket)

- 추상적인 개념과 이론은 훌륭한 코드를 작성하는 데 필요한 도구일 뿐이다.
- 개발자는 구체적인 코드를 만지며 손을 더럽힐 때 가장 많은 것을 얻어가는 존재다.

### 무엇이 문제인가

- 모든 소프트웨어 모듈에는 세 가지 목적이 있다.
  - 첫 번째 목적은 **실행 중에 제대로 동작하는 것**이다.
  - 두 번째 목적은 **변경을 위해 존재하는 것**이다.
    - 대부분의 모듈은 생명주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다.
    - 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다.
  - 세 번째 목적은 **코드를 읽는 사람과 의사소통하는 것**이다.
    - 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다.
    - 읽는 사람과 의사소통할 수 없는 모듈은 개선해야 한다.
- **이해 가능한 코드란 그 동작이 우리의 예상에서 크게 벗어나지 않는 코드다.**
- 의존성은 변경에 대한 영향을 암시한다.
  - 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에게 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.
- 객체 사이의 의존성을 완전히 없애는 것이 정답은 아니다.
  - **객체지향 설계는 서로 의존하면서 협력하는 객체들의 공동체를 구축하는 것**이다.
  - 애플리케이션의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다.
- 설계의 목표는 **객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것**이어야 한다.

### 설계 개선하기

- 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 **캡슐화**라고 부른다.
  - 캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것이다.
  - 캡슐화를 통해 객체 내부로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있기 때문에 설계를 좀 더 쉽게 변경할 수 있게 된다.
- **객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것**은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다.
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 **응집도**가 높다고 말한다.
  - 자신의 데이터를 스스로 처리하는 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있다.
- **객체의 응집도를 높이기 위해서는 객체 스스로 자신의 데이터를 책임져야 한다.**
  - **객체는 자신의 데이터를 스스로 처리하는 자율적인 존재여야 한다.** 그것이 객체의 응집도를 높이는 첫걸음이다.
  - 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길인 것이다.
- 휼륭한 객체지향 설계의 핵심은 **캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것**이다.
- 객체지향 설계에서는 독재자가 존재하지 않고 각 객체에 책임이 적절하게 분배된다.
  - 따라서, **각 객체는 자신을 스스로 책임진다.**
  - 객체지향 애플리케이션은 스스로 책임을 수행하는 자율적인 객체들의 공동체를 구성함으로써 완성된다.
- 객체는 다른 객체와의 협력이라는 문맥 안에서 특정한 역할을 수행하는 데 필요한 적절한 책임을 수행해야 한다.
  - 따라서, 객체가 어떤 데이터를 가지느냐보다는 **객체에 어떤 책임을 할당할 것이냐에 초점을 맞춰야 한다.**
- 설계를 어렵게 만드는 것은 의존성이라는 것을 기억하라.
  - 해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 결합도를 낮추는 것이다.
  - 불필요한 세부사항을 객체 내부로 캡슐화하는 것은 객체의 자율성을 높이고 응집도 높은 객체들의 공동체를 창조할 수 있게 한다.
  - **불필요한 세부사항을 캡슐화하는 자율적인 객체들이 낮은 결합도와 높은 응집도를 가지고 협력하도록 최소한의 의존성만을 남기는 것**이 훌륭한 객체지향 설계다.
- 설계는 균형의 예술이다.
  - 어떤 기능을 설계하는 방법은 한 가지 이상일 수 있다.
  - 동일한 기능을 한 가지 이상의 방법으로 설계할 수 있기 때문에 결국 설계는 트레이드오프의 산물이다.
    - 어떤 경우에도 모든 사람들을 만족시킬 수 있는 설계를 만들 수는 없다.
  - **훌륭한 설계는 적절한 트레이드오프의 결과물이라는 사실을 명심하라.**
- 의인화의 관점에서 소프트웨어를 생물로 생각하자.
  - 모든 생물처럼 소프트웨어는 태어나고, 삶을 영위하고, 그리고 죽는다.
- **훌륭한 객체지향 설계란 소프트웨어를 구성하는 모든 객체들이 자율적으로 행동하는 설계를 가리킨다.**
  - 따라서, 이해하기 쉽고 변경하기 쉬운 코드를 작성하고 싶다면 차라리 한 편의 애니메이션을 만든다고 생각하라.

### 객체지향 설계

- 설계란 코드를 배치하는 것이다.
  - 설계는 코드를 작성하는 매 순간 코드를 어떻게 배치할 것인지를 결정하는 과정에서 나온다.
  - 설계는 코드 작성의 일부이며 코드를 작성하지 않고서는 검증할 수 없다.
- 좋은 설계란 무엇인가?
  - **오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계**다.
- 코드 수정을 회피하려는 가장 큰 원인은 두려움이다.
  - 그리고 그 두려움은 요구사항 변경으로 인해 버그를 추가할지도 모른다는 불확실성에 기인한다.
- 객체지향 프로그래밍은 의존성을 효율적으로 통제할 수 있는 다양한 방법을 제공함으로써 요구사항 변경에 좀 더 수월하게 대응할 수 있는 가능성을 높여준다.
- **변경 가능한 코드란 이해하기 쉬운 코드다.**
- 객체지향의 세계에서 애플리케이션은 객체들로 구성되며 애플리케이션의 기능은 객체들 간의 상호작용을 통해 구현된다.
  - 그리고 객체들 사이의 상호작용은 객체 사이에 주고 받는 메시지로 표현된다.
- **훌륭한 객체지향 설계란 협력하는 객체 사이의 의존성을 적절하게 관리하는 설계다.**
  - 객체 간의 의존성은 애플리케이션을 수정하기 어렵게 만드는 주범이다.
  - 진정한 객체지향 설계로 나아가는 길은 협력하는 객체들 사이의 의존성을 적절하게 조절함으로써 변경에 용이한 설계를 만드는 것이다.

### 1장을 마치며

- 최근에 내가 작성한 코드들이 생각났다. 내가 만든 모듈은 세 가지 목적을 달성하고 있을까?
  - 비교적 최근에 읽는 사람과 의사소통이 가능한 코드를 만드려고 정말 애쓴 적이 있었다.
    - 화면 조작과 관련된 코드가 아니라 화면에 머무르면서 사용자의 인터랙션으로 인해 데이터가 생성되고 업데이트 되어 최종적으로 서버로 해당 데이터를 보내는 코드
    - 일련의 과정이 꽤나 복잡했기 떄문에 읽기 좋은 코드를 만들기 위해 계속 로직을 함수로 분리하고, 함수명도 열심히 고민해서 지었다.
    - 결과적으로 크게 나아지진 않았다. 함수로 열심히 분리했지만 여전히 복잡했다.
  - 책을 읽고 다시 생각해보니 내가 분리한 함수에 꽤 많은 의존성(ex. 파라미터가 너무 많다거나)이 존재했던 것 같다.
    - "재고"라는 객체를 뽑아낼 수 있을 것 같은데 위에서 언급한 일련의 과정을 객체지향 설계로 어떻게 보완할 수 있지 않을까?
    - "구조는 객체지향 설계로 로직은 함수형으로 해결하라!"라는 유인동 개발자님의 말씀이 떠오른다. 어떻게 잘 적용해볼 수 있지 않을까 ..
- "캡슐화"는 리액트의 커스텀 훅이 생각이 났다.
  - 여러 곳에서 사용되는 로직을 커스텀 훅으로 분리하여 필요한 컴포넌트에서 호출하여 사용하기도 하지만
  - 특정 로직을 커스텀 훅으로 분리하여 해당 훅을 호출하는 컴포넌트의 관심사가 아니라고 생각되는 세부사항은 훅으로 캡슐화하고 훅에서 반환한 값 또는 함수만을 컴포넌트가 사용하도록 만드는 형태
- 책을 읽다 보면 프론트엔드 실무의 어디에서 이러한 객체지향 설계를 적용할 수 있을까란 생각이 들긴 한다.
  - 비슷하게 유튜브 개발바닥에서도 "웹 프론트엔드에서 DI나 MVVM과 같은 아키텍처 또는 패턴이 잘 정립되지 않는 이유"에 대해 한바탕 불이 붙은 적이 있었는데 좋은 댓글이 많았지만 그 중에서도 꽤 공감하는 댓글이 있어 남겨본다.
  - 생각해보니 최근에 좋은 [예제](https://blog.ban-life.com/%EC%8B%A0%EA%B7%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EA%B0%80-%EB%82%98%EC%99%94%EB%8B%A4%EA%B3%A0-%EA%B2%81%EB%82%98-%ED%97%98%ED%95%9C%EA%B2%8C-b549252bc8a5)를 봤었다. 백엔드스럽게 프론트엔드 코드 작성하기랄까

> 일단 웹프론트는 DI나 MVVM 같은 그런걸 쓸 필요를 잘 못느끼는것 같습니다.
>
> 백엔드와 프론트의 차이점을 이야기 하면 백엔드는 독립성을 유지해야 하는 단위가 업무이며 이를 클래스로 구성을 하고 있습니다.
>
> 하지만 프론트의 경우는 독립성을 유지를 해야하는 단위가 화면이죠.  
> 업무에 필요한 데이터의 경우는 각종 모델링 등을 통해서 계층 관계가 이루어 지지만, 프론트의 경우는 다루어야 할 대상이 눈에 보이는 화면의 조각의 모음입니다.
>
> 그리고 이 화면의 경우는 복잡한 업무가 필요한게 아니라 서버에서 데이터를 받아서 표시를 하고 UX, 인터렉션 처리가 주 업무입니다.  
> 데이터의 경우는 이미 서버에서 인터페이싱된 데이터를 보내주기 때문이죠.
>
> 실제로 웹프론트에서도 MVVM이 안쓰인건 아니었습니다.  
> 영상에서 나왔듯이 angular에서 먼저 MVVM 패턴을 도입을 했지만 결국 시장의 선택을 받은건 리액트나 뷰와 같은 컴포넌트 중심의 툴입니다.
>
> 리액트나 뷰에서 state 라는 개념을 통해서 어느 정도 MVVM의 개념(observer)을 가지고 있고, 서버의 경우는 인터페이스를 통해서 각 객체간의 독립성을 보장을 해주지만, 리액트나 뷰의 컴포넌트의 경우는 props가 그 인터페이스 역할을 하며 컴포넌트의 독립성을 보장을 해줍니다.
>
> 실제로 리액트의 경우는 초기에는 클래스 기반이었다가 16 버전에서는 클래스를 버리고 hook이라는 작은 function 개념으로 돌아섰습니다.  
> 리액트 개발진들이 밝히기를 여러 가지 개발 프로젝트를 관찰한 결과 클래스를 써야할만큼 복잡한 업무가 거의 없고 클래스는 오히려 코드의 난이도만 높힌다고 했습니다.
>
> 심지어 예전에는 mobx나 redux를 이용해서 업무 영역을 store 분리하는게 대세였지만 요즘에는 이러한 거대 store도 조금씩 버려지고(?) 있는 추세인 것 같습니다.
>
> 실제 개발 코드 store 중 70% ~ 80% 이상이 단순 repository의 연계이고 소수의 업무 코드를 위해 store를 유지하는게 오히려 더 비효율적이라고 생각 되기 때문입니다. 즉, 화면을 만들때 가장 큰 관심사항은 얼마나 빨리 적은 비용으로 화면을 구성을 하고, 화면의 변화에 빠르게 대응을 할 수 있고 유지보수에 용이하냐 입니다.
>
> 그러한 개념으로 볼때 컴포넌트 기반의 리액트나 뷰는 제격인거죠.  
> 눈에 보이는 구성요소를 컴포넌트로 작게 분리를 할 수 있고, 컴포넌트는 적은 비용으로 빠르게 제작이 가능합니다. 그리고 이러한 컴포넌트는 독립성을 유지하며 재활용성이 띄어납니다.
>
> MVVM이나 DI를 쓰지 않더라도 좋은 코드의 특성을 지니면서 MVVM이나 DI 대비 개발 비용 조차 저렴합니다. 이러한 요소들이 프론트에서는 OOP보다 함수형 언어가 더 잘 맞다고 보고 있구요(개인적으로는 백엔드 분야에서도 OOP보다는 함수형 언어쪽이 더 작은 비용으로 더 좋은 목적을 수행할 수 있다고 보고 서서히 변화해 나갈꺼라고 생각합니다).
>
> 영상이나 댓글을 보면 안드로이드나 iOS이 경우는 MVVM이나 DI가 있다고 말씀하시는데 저는 오히려 이러한 native 영역이 과도기라고 보고 있습니다. native와 같이 전체 화면을 하나의 요소(클래스)로 두고 MVVM 및 DI 등을 통한 각종 객체지향적인 기법으로 개발을 하는 것보다 화면을 조각 내어서 컴포넌트 기반으로 하나의 화면 조각을 작게 가져가는게 효율이 더 좋기 때문입니다.
>
> 이러한 작은 컴포넌트 조각들은 MVVM과 같은 패턴이나 OOP는 어울리지가 않죠.
>
> native 영역도 native 개발 툴보다는 flutter와 같은 통합툴로 이전이 될거라고 생각되고, 이러한 툴들은 컴포넌트 기반으로 구성이 되고 있습니다. 즉, 프론트는 발전방향이 MVC -> MVVM -> 리액트 와 같은 component 형태의 개발 방식으로 진화가 되는것이죠.
>
> 암튼, 정리하면 백엔드와 프론트는 다루는 데이터가 다르기 때문에, 발전되는 아키텍처의 모습도 다르다고 보고 있습니다.
