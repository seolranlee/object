### # Chapter 04 설계 품질과 트레이드 오프

- 데이터 중심의 설계를 진행한 후, 책임 중심의 설계와 비교

#### # 01 데이터 중심의 영화 예매 시스템

- `상태(데이터)`에 초점을 맞추면 안되는 이유

  - 객체의 `상태`는 `구현`에 속함
  - 구현에 관한 세부사항이 `인터페이스에 녹아들게 됨`

- 데이터 중심의 Movie 클래스 설계
  - 할인 조건, 할인 정책이 Movie 안에 인스턴스 변수로 선언
  - \*\* 문제는 `위 정보를 판단`하기 위해 `movieType이라는 새로운 인스턴스 변수가 생기게 됨`
    - 이렇게 `배타적으로 사용될 인스턴스 변수`가 포함되는 현상은, 데이터 중심의 설계를 할때 자주 일어나는 패턴

#### # 02 설계 트레이드 오프

- 세 가지 척도: `캡슐화, 결합도, 응집도`

- `캡슐화`

  - `구현`의 의미
    - \*\* 나중에 `변경될 가능성이 높은 어떤 것`
  - `인터페이스`의 의미
    - 상대적으로 `안정적`인 부분
  - `캡슐화`의 정의, 의의
    - \*\* `구현(변경 가능성이 높은 것)`을 객체 내부에 숨기는 것
    - \*\* 단순히 이것저것 모아두는 것이 아님
    - 객체 지향에서 가장 중요한 원리

- 응집도와 결합도
  - `응집도`
    - 모듈 내부에 포함된 요소들이 연관되어 있는 정도
  - `결합도`
    - 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지
  - \*\* 이 둘은 `변경`의 관점에서 생각해야 함
    - 응집도
      - 변경이 발생할 때, `모듈 내부에서` 발생하는 변경의 정도
    - 결합도
      - 변경이 발생할 때, `다른 모듈에서` 발생하는 변경의 정도

#### # 03 데이터 중심의 영화 예매 시스템의 문제점

- `기능적`인 관점에서는 `동일`

  - 하지만 `캡슐화를 위반`하고, `높은 결합도`, `낮은 응집도`를 가지게 될 확률이 크다

- 캡슐화 위반

  - \*\* `접근제어자, getter, setter를 활용`하고 있기 때문에, `마치 캡슐화를 지키는 것 처럼 보인다`
  - 사실은 전혀 캡슐화되어있지 않음
    - `각 인스턴스 변수명이 public 인터페이스에 노출`되어있어서, 외부에서는 이런 사실을 모두 알게 된다.
  - \*\* `문맥을 고려하지 않고 만든 객체`는 `과도한 접근자와 수정자`을 가지게 된다.
    - `사용될 문맥을 모르기 때문`에, `모든 경우에 대해서 열어둘 수 밖에 없기 때문`
    - 막연한 추측밖에 할 수 없기 때문에, 프로그래머는 위와 같은 압박을 가질수 밖에 없다.

- 높은 결합도

  - `대부분의 제어로직`들이 `하나의 객체`에 들어가게 된다.

- 낮은 응집도

- `단일 책임 원칙`
  - 클래스는 `단 하나의 변경 이유`만 가져야 한다.

#### # 04 자율적인 객체를 향해

- `캡슐화`는 객체지향 설계의 `제 1원리`

  - 가장 중요함
  - 객체는 `스스로의 상태를 책임`져야 하며, 외부에서는 `인터페이스에 정의된 메서드`를 통해서만 상태에 접근할 수 있어야 한다.
    - \*\* 여기서 말하는 메서드는 단순한 `getter, setter가 아님`
    - 아무리 `private로 설정했다고 하더라도`, 외부에 `getter, setter를 노출해주고 있다면`, `캡슐화를 위반`하고 있는 것
      - 이렇게 해두고, `구현부가 전부 외부에 있는 모양새`라면 잘못된 것

- 조금 수정된 예제 코드
  - `단순히 getter, setter만 소유` -> 각 책임을 `각 클래스가 조금씩 들고갔기` 때문에 결함도 측면에서는 조금 나아짐
  - \*\* 그러나 아직 아쉬운 부분이 많다

#### # 05 하지만 여전히 부족하다

- 수정한 두번째 설계 역시 데이터 중심의 설계에 가까움

  - 조금 나아진 수준이지, 이전과 `동일한 문제는 대부분 발생`

- 캡슐화 위반

  - 스스로의 상태를 관리하고 있긴 하지만, 메서드의 매개변수의 보면 이상한 점이 있다.
    - \*\* 외부에서 `매개변수를 보면`, 객체 내부에 `어떤 상태가 들어가 있는지` 알 수 있다.
    - 결국에, 내부 상태가 변경될때, `외부에서도 수정이 필요하다`는 점에서 `구현에 대한 캡슐화`는 이루지 못했다고 할 수 있다.
  - \*\* 매개변수가 없는 메서드의 경우도 마찬가지
    - 매개변수가 없는 대신, `각 케이스에 대해서 동일한 형태의 함수들이 모두 선언`되어 있음
      - 할인정책이 `추가되거나, 제거되는 경우`에 수정이 필요함

- 높은 결합도, 낮은 응집도
  - 결국 위 캡슐화 위반으로 파생되는 결합도에 대한 문제가 발생

#### # 06 데이터 중심 설계의 문제점

- \*\* 데이터 중심 설계가 `변경에 취약`한 2가지 이유

  - `너무 이른 시기`에 데이터에 대해 `결정하도록 강요`
  - 협력이라는 `문맥을 고려하지 않고`, `고립시킨채` 책임을 강요

- `올바른 객체지향 설계`는 항상 객체의 내부가 아니라, `외부에 초점`이 맞춰져있어야 한다.

  - 협력, 책임

- `데이터 중심의 설계`는 `객체의 내부에 집중`하게 된다.
  - `문맥을 고려하지 않고`, 데이터만 생각하게 됨
  - `협력(인터페이스)`에 억지로 데이터를 끼워 맞추게 됨
  - \*\* 자연스럽게 `외부에 내부 구현, 상태가 노출`
  - => 결국 `캡슐화를 위반`하게 되고, `낮은 응집도, 높은 결합도`를 가지게 된다.
