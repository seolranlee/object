### # Chapter 08 의존성 관리하기

- `협력`은 필요하나 과도하다면 문제가 됨
- `필요한 협력`만 유지하도록 하는게 중요

#### # 01 의존성 이해하기

##### # 변경과 의존성

- `의존성`은 항상 `단방향`, `변경에 영향`을 줌
- 그림 8.3 의존성 표현 그림
  - 함수에서 가질수 있는 의존성을 보여줌
    - `클래스 내부 변수`에 대한 의존성
    - 인자로 받는 `매개변수`에 대한 의존성

##### # 의존성 전이

- 의존성은 `직접 의존성`과 `간접 의존성`으로 나뉘어진다.
  - 모든 경우에 간접 의존성이 발생하는 것은 아님
    - 해당 클래스가 `캡슐화를 잘 해두었다면` 간접 의존성이 발생하지 않을 수 있다.
- \*\* 클래스 외외에도, `변경과 관련된 모든 개념`에도 `의존성이라는 개념이 적용`됨
  - `객체, 모듈, 실행 시스템` 등

##### # 런타임 의존성과 컴파일타임 의존성

- `동적 언어`는 `컴파일 타임이 없기 때문에`, 컴파일타임의 의미에 대해서 잘 생각해봐야 한다.
- \*\* `유연하고 재사용가능한 설계`를 하기 위해서는 `동일한 소스코드`를 가지고 `다양한 실행 구조`를 만들 수 있어야 한다.
  - => 객체들이 `런타임 의존성`을 갖게 만들어야 함

###### # 컨텍스트 독립성

- 객체는 다른 객체의 구체적인 클래스를 알면 좋지 않다.
  - \*\* `사용될 때`, `특정 문맥에 강하게 결합`되기 때문
    - 프론트개발할때도 많이 겪게되는 상황

##### # 의존성 해결

- \*\* `컨텍스트 독립성`을 가지면서, 객체와 `런타임 의존성`을 갖게 할수 있는 방법들

  - 객체 생성시, `생성자`를 동해
  - 객체 생성 후, `setter`를 통해
  - 함수를 실행할 때, `메서드 인자`를 통해

- `setter의 단점`
  - 객체 생성 후 `의존성이 설정되기 전에 setter가 호출`되는 경우, `시스템이 불안정`할 수 있음
    - => `생성자 방식`과 `혼합`해서 사용하면 그 불안정한 부분을 해결할 수 있음

#### # 02 유연한 설계

##### # 의존성과 결합도

- `바람직한 의존성`이란, `재사용가능한 의존성`을 말하는 것
  - 예시 코드에서 percentDiscountPolicy에 대한 Movie 클래스의 의존성은 재사용할 수 없는 의존성
    - 특정 할인정책에만 적용되는 문제

##### # 지식이 결합을 낳는다

- `결합도`의 정도는 다른 요소에 대해 `알고있는 지식의 양`에 `비례`
- \*\* `구체적인 클래스` 대신 `추상화`를 사용하면 지식의 양을 줄일 수 있음

##### # 추상화에 의존하라

- 중요한 것은 `실행 컨텍스트`에 대해 `알아야 하는 정보를 줄일수록` 결합도가 낮아진다는 것

##### # 명시적인 의존성

- 단순히 `추상화를 하는 것만으로는 부족`
- \*\* `의존성이 감춰진 경우`를 주의해야 함

  - `외부에는 의존성이 드러나지 않는데`(ex. 인자로 받지 않는데), `내부에서 의존성이 발생하는 경우`(ex. 내부에서 인스턴스를 생성)
  - \*\* 생성자 함수에서 특정 클래스를 인자로 받고, 안 받고의 차이는 의존성을 `명시적으로 드러내냐` or `숨기냐`의 차이
    - 예전부터 평소에 궁금했던 부분

- \*\* 숨겨진 의존성이 위험한 이유

  - `내부` 구현을 `직접 살펴봐야함`
  - \*\* 더 큰 문제는, `다른 컨텍스트에서 사용할 수 없어짐`
    - 내부 구현을 수정해야함

- \*\* `숨겨진 의존성을 밖으로 꺼내서` 명시적으로 `외부에 알려라`

##### # new는 해롭다

- `결합도` 측면에서 `new가 해로운 이유`

  - new 연산자를 사용하기 위해서는, `구체 클래스를 직접 기술`해야 한다.
  - 추가로, 당연히 구체 클래스 `생성자의 인자`도 알아야 한다.
    - => 알아야 하는 `지식의 양이 늘어남`

- 해결 방법
  - \*\* 인스턴스 `생성 로직`과 `사용 로직`을 분리
    - => 분리하는 법은 앞에서 봤던 `의존성 해결법`과 동일
      - (`생성자, setter, 메서드`)

##### # 가끔은 생성해도 무방하다

- 대부분의 로직에서 `협력하는 객체가 고정적`일 경우, `생성 로직이 내부에 있어도 무방`하다
  - => 오히려 `호출부의 재사용 코드 중복을 막을 수 있음`

##### # 표준 클래스에 대한 의존은 해롭지 않다

- `의존성 문제를 해결하하는 이유`는, 결국 `변경에 잘 대응하기 위함`
  - 따라서 `표준 클래스에 대한 의존성은 해롭지 않다`

##### # 컨텍스트 확장하기

- 앞에서 했던 정책 확장 예시
  - 특별한 내용 없음

##### # 조합 가능한 행동

- `유연하고 재사용 가능한 설계`는 객체가 `어떻게(how)` 하는지를 장황하게 나열하지 않고도 객체의 조합을 통해 `무엇(what)`을 하는지를 표현하는 클래스들로 구성된다
  - \*\* 결국에는 코드가 `선언적`인 형태를 띄게 된다
